<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#
  const int maxParameters = 5;

  // Return types supported by the system
  var returnTypes = new[] { "Int", "Long", "Float", "Double", "Decimal", "String", "Bool" };

  // Generate type parameter list: T1, T2, ..., TN
  string TypeParams(int count)
  {
    if (count == 0) return string.Empty;
    var parts = new string[count];
    for (var i = 0; i < count; i++)
    {
      parts[i] = $"T{i + 1}";
    }
    return string.Join(", ", parts);
  }

  // Generate generic type arguments: <T1, T2, ..., TN, TResult>
  string TypeArgs(int paramCount)
  {
    return paramCount == 0 ? "<TResult>" : $"<{TypeParams(paramCount)}, TResult>";
  }

  // Map return type to C# type
  string GetCSharpType(string returnType)
  {
    return returnType switch
    {
      "Int" => "int",
      "Long" => "long",
      "Float" => "float",
      "Double" => "double",
      "Decimal" => "decimal",
      "String" => "string",
      "Bool" => "bool",
      _ => "object"
      };
  }

  // Map return type to Type enum value
  string GetTypeEnumValue(string returnType)
  {
    return returnType switch
    {
      "Int" => "Integer",
      "Bool" => "Boolean",
      _ => returnType
      };
  }

  // Map return type to TypeTraits method
  string GetTraitMethod(string returnType)
  {
    return returnType == "String" ? "ToStringValue" : $"To{returnType}";
  }

  // Add 's' suffix for plural when count != 1
  string Plural(int count)
  {
    return count != 1 ? "s" : string.Empty;
  }
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//     Template: CustomFunction.Generated.tt
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using EpsilonScript.AST;

namespace EpsilonScript.Function
{
  public abstract partial class CustomFunction
  {
<#
  for (var paramCount = 0; paramCount <= maxParameters; paramCount++)
  {
    var typeArgs = TypeArgs(paramCount);
    var funcParams = TypeParams(paramCount);
    var hasParams = paramCount > 0;
#>
    public static CustomFunction Create<#= typeArgs #>(string name, Func<<#= hasParams ? $"{funcParams}, " : string.Empty #>TResult> func, bool isConstant = false)
    {
      return new CustomFunction<#= typeArgs #>(name, func, isConstant);
    }

<#
  }
#>
  }

<#
  for (var paramCount = 0; paramCount <= maxParameters; paramCount++)
  {
    var typeArgs = TypeArgs(paramCount);
    var funcParams = TypeParams(paramCount);
    var hasParams = paramCount > 0;
#>
  // ==========================================================================
  // CustomFunction with <#= paramCount #> parameter<#= Plural(paramCount) #>
  // ==========================================================================

  /// <summary>
  /// Custom function implementation with <#= paramCount #> parameter<#= Plural(paramCount) #>.
  /// </summary>
  public sealed class CustomFunction<#= typeArgs #> : CustomFunction
  {
<#
    if (hasParams)
    {
#>
    private static readonly Type[] ParameterCache = new[]
    {
<#
      for (var i = 1; i <= paramCount; i++)
      {
#>
      TypeTraits<T<#= i #>>.ValueType<#= i < paramCount ? "," : string.Empty #>
<#
      }
#>
    };
<#
    }
#>
    private readonly Func<<#= hasParams ? $"{funcParams}, " : string.Empty #>TResult> _func;

    public CustomFunction(string name, Func<<#= hasParams ? $"{funcParams}, " : string.Empty #>TResult> func, bool isConstant = false)
      : base(name, isConstant, <#=
      hasParams ? "ParameterCache" : "Array.Empty<Type>()" #>, TypeTraits<TResult>.ValueType)
    {
      _func = func ?? throw new ArgumentNullException(nameof(func));
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private TResult Invoke(List<Node> parameters)
    {
      EnsureParameterCount(parameters);
      return _func(<#
    if (paramCount > 0)
    {
      for (var i = 1; i <= paramCount; i++)
      {
#>TypeTraits<T<#= i #>>.Read(parameters[<#= i - 1 #>])<#= i < paramCount ? ", " : string.Empty #><#
      }
    }
#>);
    }
<#
    foreach (var returnType in returnTypes)
    {
#>

    internal override <#= GetCSharpType(returnType) #> Execute<#= returnType #>(List<Node> parameters)
    {
      EnsureReturnType(Type.<#= GetTypeEnumValue(returnType) #>);
      return TypeTraits<TResult>.<#= GetTraitMethod(returnType) #>(Invoke(parameters));
    }
<#
    }
#>
  }
<#
  }
#>
}
