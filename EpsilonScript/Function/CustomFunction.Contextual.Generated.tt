<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#
  const int maxContextVars = 3;
  const int maxContextParams = 3;

  // Return types supported by the system
  var returnTypes = new[] { "Int", "Long", "Float", "Double", "Decimal", "String", "Bool" };

  // Generate type parameter list: T1, T2, ..., TN
  string TypeParams(int count)
  {
    if (count == 0) return string.Empty;
    var parts = new string[count];
    for (var i = 0; i < count; i++)
    {
      parts[i] = $"T{i + 1}";
    }
    return string.Join(", ", parts);
  }

  // Generate type arguments including TResult: <T1, T2, ..., TN, TResult>
  string TypeArgs(int totalCount)
  {
    return totalCount == 0 ? "<TResult>" : $"<{TypeParams(totalCount)}, TResult>";
  }

  // Generate context variable parameter list for factory method
  string ContextVarParams(int contextCount)
  {
    var parts = new string[contextCount];
    for (var i = 1; i <= contextCount; i++)
    {
      parts[i - 1] = $"VariableId contextVar{i}";
    }
    return string.Join(", ", parts);
  }

  // Generate Func type signature
  string FuncType(int totalTypeParams)
  {
    return totalTypeParams == 0 ? "Func<TResult>" : $"Func<{TypeParams(totalTypeParams)}, TResult>";
  }

  // Generate class name suffix (empty for 1 context, "2" for 2, "3" for 3)
  string ClassSuffix(int contextCount)
  {
    return contextCount == 1 ? string.Empty : contextCount.ToString();
  }

  // Map return type to C# type
  string GetCSharpType(string returnType)
  {
    return returnType switch
    {
      "Int" => "int",
      "Long" => "long",
      "Float" => "float",
      "Double" => "double",
      "Decimal" => "decimal",
      "String" => "string",
      "Bool" => "bool",
      _ => "object"
      };
  }

  // Map return type to Type enum value
  string GetTypeEnumValue(string returnType)
  {
    return returnType switch
    {
      "Int" => "Integer",
      "Bool" => "Boolean",
      _ => returnType
      };
  }

  // Map return type to TypeTraits method
  string GetTraitMethod(string returnType)
  {
    return returnType == "String" ? "ToStringValue" : $"To{returnType}";
  }

  // Add 's' suffix for plural when count != 1
  string Plural(int count)
  {
    return count != 1 ? "s" : string.Empty;
  }
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//     Template: CustomFunction.Contextual.Generated.tt
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using EpsilonScript.AST;

namespace EpsilonScript.Function
{
  public abstract partial class CustomFunction
  {
<#
  // Generate CreateContextual factory methods for all combinations
  for (var contextCount = 1; contextCount <= maxContextVars; contextCount++)
  {
#>
    // =========================================================================
    // CreateContextual with <#= contextCount #> Context Variable<#= Plural(contextCount) #>
    // =========================================================================

<#
    for (var paramCount = 0; paramCount <= maxContextParams; paramCount++)
    {
      var totalTypeParams = contextCount + paramCount;
      var typeArgs = TypeArgs(totalTypeParams);
      var contextVarParams = ContextVarParams(contextCount);
      var funcType = FuncType(totalTypeParams);
      var classSuffix = ClassSuffix(contextCount);
#>
    public static CustomFunction CreateContextual<#= typeArgs #>(
      string name,
      <#= contextVarParams #>,
      <#= funcType #> func,
      bool isConstant = false)
    {
      return new ContextualCustomFunction<#= classSuffix #><#= typeArgs #>(name, <#=
        string.Join(", ", Enumerable.Range(1, contextCount).Select(i => $"contextVar{i}")) #>, func, isConstant);
    }

<#
    } // end paramCount loop
  } // end contextCount loop
#>
  }

<#
  // Generate implementation classes for all combinations
  for (var contextCount = 1; contextCount <= maxContextVars; contextCount++)
  {
#>
  // ===========================================================================
  // <#= contextCount #> Context Variable<#= Plural(contextCount) #> Implementations
  // ===========================================================================

<#
    for (var paramCount = 0; paramCount <= maxContextParams; paramCount++)
    {
      var totalTypeParams = contextCount + paramCount;
      var typeArgs = TypeArgs(totalTypeParams);
      var classSuffix = ClassSuffix(contextCount);
      var className = "ContextualCustomFunction" + classSuffix;
      var funcType = FuncType(totalTypeParams);
      var contextVarParams = ContextVarParams(contextCount);
      var hasParams = paramCount > 0;
#>
  /// <summary>
  /// Contextual custom function with <#= contextCount #> context variable<#= Plural(contextCount) #> and <#= paramCount #> parameter<#= Plural(paramCount) #>.
  /// </summary>
  internal sealed class <#= className #><#= typeArgs #> : CustomFunction
  {
<#
      if (hasParams)
      {
#>
    private static readonly Type[] ParameterCache = new[]
    {
<#
        for (var i = 1; i <= paramCount; i++)
        {
          var typeIndex = contextCount + i;
#>
      TypeTraits<T<#= typeIndex #>>.ValueType<#= i < paramCount ? "," : string.Empty #>
<#
        }
#>
    };
<#
      }
#>
    private readonly <#= funcType #> _func;
<#
      for (var i = 1; i <= contextCount; i++)
      {
#>
    private readonly VariableId _contextVar<#= i #>;
<#
      }
#>

    public <#= className #>(string name, <#= contextVarParams #>, <#= funcType #> func, bool isConstant)
      : base(name, isConstant, <#=
        hasParams ? "ParameterCache" : "Array.Empty<Type>()" #>, TypeTraits<TResult>.ValueType, hasContext: true)
    {
      _func = func ?? throw new ArgumentNullException(nameof(func));
<#
      for (var i = 1; i <= contextCount; i++)
      {
#>
      _contextVar<#= i #> = contextVar<#= i #>;
<#
      }
#>
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private TResult Invoke(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureParameterCount(parameters);
<#
      for (var i = 1; i <= contextCount; i++)
      {
#>

      if (!context.TryGetVariable(_contextVar<#= i #>, out T<#= i #> ctx<#= i #>))
      {
        throw new RuntimeException($"Context variable '{_contextVar<#= i #>}' not found");
      }
<#
      }
#>

      return _func(<#
      var argList = new System.Collections.Generic.List<string>();
      for (var i = 1; i <= contextCount; i++)
      {
        argList.Add($"ctx{i}");
      }
      for (var i = 0; i < paramCount; i++)
      {
        var typeIndex = contextCount + i + 1;
        argList.Add($"TypeTraits<T{typeIndex}>.Read(parameters[{i}])");
      }
      Write(string.Join(", ", argList));
#>);
    }
<#
      foreach (var returnType in returnTypes)
      {
#>

    internal override <#= GetCSharpType(returnType) #> Execute<#= returnType #>(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.<#= GetTypeEnumValue(returnType) #>);
      return TypeTraits<TResult>.<#= GetTraitMethod(returnType) #>(Invoke(context, parameters));
    }
<#
      }
#>
  }
<#
    } // end paramCount loop
  } // end contextCount loop
#>
}
