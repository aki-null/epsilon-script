//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//     Template: CustomFunction.Contextual.Generated.tt
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using EpsilonScript.AST;

namespace EpsilonScript.Function
{
  public abstract partial class CustomFunction
  {
    // =========================================================================
    // CreateContextual with 1 Context Variable
    // =========================================================================

    public static CustomFunction CreateContextual<T1, TResult>(
      string name,
      VariableId contextVar1,
      Func<T1, TResult> func,
      bool isDeterministic = false)
    {
      return new ContextualCustomFunction<T1, TResult>(name, contextVar1, func, isDeterministic);
    }

    public static CustomFunction CreateContextual<T1, T2, TResult>(
      string name,
      VariableId contextVar1,
      Func<T1, T2, TResult> func,
      bool isDeterministic = false)
    {
      return new ContextualCustomFunction<T1, T2, TResult>(name, contextVar1, func, isDeterministic);
    }

    public static CustomFunction CreateContextual<T1, T2, T3, TResult>(
      string name,
      VariableId contextVar1,
      Func<T1, T2, T3, TResult> func,
      bool isDeterministic = false)
    {
      return new ContextualCustomFunction<T1, T2, T3, TResult>(name, contextVar1, func, isDeterministic);
    }

    public static CustomFunction CreateContextual<T1, T2, T3, T4, TResult>(
      string name,
      VariableId contextVar1,
      Func<T1, T2, T3, T4, TResult> func,
      bool isDeterministic = false)
    {
      return new ContextualCustomFunction<T1, T2, T3, T4, TResult>(name, contextVar1, func, isDeterministic);
    }

    // =========================================================================
    // CreateContextual with 2 Context Variables
    // =========================================================================

    public static CustomFunction CreateContextual<T1, T2, TResult>(
      string name,
      VariableId contextVar1, VariableId contextVar2,
      Func<T1, T2, TResult> func,
      bool isDeterministic = false)
    {
      return new ContextualCustomFunction2<T1, T2, TResult>(name, contextVar1, contextVar2, func, isDeterministic);
    }

    public static CustomFunction CreateContextual<T1, T2, T3, TResult>(
      string name,
      VariableId contextVar1, VariableId contextVar2,
      Func<T1, T2, T3, TResult> func,
      bool isDeterministic = false)
    {
      return new ContextualCustomFunction2<T1, T2, T3, TResult>(name, contextVar1, contextVar2, func, isDeterministic);
    }

    public static CustomFunction CreateContextual<T1, T2, T3, T4, TResult>(
      string name,
      VariableId contextVar1, VariableId contextVar2,
      Func<T1, T2, T3, T4, TResult> func,
      bool isDeterministic = false)
    {
      return new ContextualCustomFunction2<T1, T2, T3, T4, TResult>(name, contextVar1, contextVar2, func, isDeterministic);
    }

    public static CustomFunction CreateContextual<T1, T2, T3, T4, T5, TResult>(
      string name,
      VariableId contextVar1, VariableId contextVar2,
      Func<T1, T2, T3, T4, T5, TResult> func,
      bool isDeterministic = false)
    {
      return new ContextualCustomFunction2<T1, T2, T3, T4, T5, TResult>(name, contextVar1, contextVar2, func, isDeterministic);
    }

    // =========================================================================
    // CreateContextual with 3 Context Variables
    // =========================================================================

    public static CustomFunction CreateContextual<T1, T2, T3, TResult>(
      string name,
      VariableId contextVar1, VariableId contextVar2, VariableId contextVar3,
      Func<T1, T2, T3, TResult> func,
      bool isDeterministic = false)
    {
      return new ContextualCustomFunction3<T1, T2, T3, TResult>(name, contextVar1, contextVar2, contextVar3, func, isDeterministic);
    }

    public static CustomFunction CreateContextual<T1, T2, T3, T4, TResult>(
      string name,
      VariableId contextVar1, VariableId contextVar2, VariableId contextVar3,
      Func<T1, T2, T3, T4, TResult> func,
      bool isDeterministic = false)
    {
      return new ContextualCustomFunction3<T1, T2, T3, T4, TResult>(name, contextVar1, contextVar2, contextVar3, func, isDeterministic);
    }

    public static CustomFunction CreateContextual<T1, T2, T3, T4, T5, TResult>(
      string name,
      VariableId contextVar1, VariableId contextVar2, VariableId contextVar3,
      Func<T1, T2, T3, T4, T5, TResult> func,
      bool isDeterministic = false)
    {
      return new ContextualCustomFunction3<T1, T2, T3, T4, T5, TResult>(name, contextVar1, contextVar2, contextVar3, func, isDeterministic);
    }

    public static CustomFunction CreateContextual<T1, T2, T3, T4, T5, T6, TResult>(
      string name,
      VariableId contextVar1, VariableId contextVar2, VariableId contextVar3,
      Func<T1, T2, T3, T4, T5, T6, TResult> func,
      bool isDeterministic = false)
    {
      return new ContextualCustomFunction3<T1, T2, T3, T4, T5, T6, TResult>(name, contextVar1, contextVar2, contextVar3, func, isDeterministic);
    }

  }

  // ===========================================================================
  // 1 Context Variable Implementations
  // ===========================================================================

  /// <summary>
  /// Contextual custom function with 1 context variable and 0 parameters.
  /// </summary>
  internal sealed class ContextualCustomFunction<T1, TResult> : CustomFunction
  {
    private readonly Func<T1, TResult> _func;
    private readonly VariableId _contextVar1;

    public ContextualCustomFunction(string name, VariableId contextVar1, Func<T1, TResult> func, bool isDeterministic)
      : base(name, isDeterministic, Array.Empty<Type>(), TypeTraits<TResult>.ValueType, hasContext: true)
    {
      _func = func ?? throw new ArgumentNullException(nameof(func));
      _contextVar1 = contextVar1;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private TResult Invoke(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureParameterCount(parameters);

      if (!context.TryGetVariable(_contextVar1, out T1 ctx1))
      {
        throw new RuntimeException($"Context variable '{_contextVar1}' not found");
      }

      return _func(ctx1);
    }

    internal override int ExecuteInt(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Integer);
      return TypeTraits<TResult>.ToInt(Invoke(context, parameters));
    }

    internal override long ExecuteLong(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Long);
      return TypeTraits<TResult>.ToLong(Invoke(context, parameters));
    }

    internal override float ExecuteFloat(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Float);
      return TypeTraits<TResult>.ToFloat(Invoke(context, parameters));
    }

    internal override double ExecuteDouble(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Double);
      return TypeTraits<TResult>.ToDouble(Invoke(context, parameters));
    }

    internal override decimal ExecuteDecimal(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Decimal);
      return TypeTraits<TResult>.ToDecimal(Invoke(context, parameters));
    }

    internal override string ExecuteString(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.String);
      return TypeTraits<TResult>.ToStringValue(Invoke(context, parameters));
    }

    internal override bool ExecuteBool(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Boolean);
      return TypeTraits<TResult>.ToBool(Invoke(context, parameters));
    }
  }
  /// <summary>
  /// Contextual custom function with 1 context variable and 1 parameter.
  /// </summary>
  internal sealed class ContextualCustomFunction<T1, T2, TResult> : CustomFunction
  {
    private static readonly Type[] ParameterCache = new[]
    {
      TypeTraits<T2>.ValueType
    };
    private readonly Func<T1, T2, TResult> _func;
    private readonly VariableId _contextVar1;

    public ContextualCustomFunction(string name, VariableId contextVar1, Func<T1, T2, TResult> func, bool isDeterministic)
      : base(name, isDeterministic, ParameterCache, TypeTraits<TResult>.ValueType, hasContext: true)
    {
      _func = func ?? throw new ArgumentNullException(nameof(func));
      _contextVar1 = contextVar1;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private TResult Invoke(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureParameterCount(parameters);

      if (!context.TryGetVariable(_contextVar1, out T1 ctx1))
      {
        throw new RuntimeException($"Context variable '{_contextVar1}' not found");
      }

      return _func(ctx1, TypeTraits<T2>.Read(parameters[0]));
    }

    internal override int ExecuteInt(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Integer);
      return TypeTraits<TResult>.ToInt(Invoke(context, parameters));
    }

    internal override long ExecuteLong(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Long);
      return TypeTraits<TResult>.ToLong(Invoke(context, parameters));
    }

    internal override float ExecuteFloat(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Float);
      return TypeTraits<TResult>.ToFloat(Invoke(context, parameters));
    }

    internal override double ExecuteDouble(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Double);
      return TypeTraits<TResult>.ToDouble(Invoke(context, parameters));
    }

    internal override decimal ExecuteDecimal(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Decimal);
      return TypeTraits<TResult>.ToDecimal(Invoke(context, parameters));
    }

    internal override string ExecuteString(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.String);
      return TypeTraits<TResult>.ToStringValue(Invoke(context, parameters));
    }

    internal override bool ExecuteBool(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Boolean);
      return TypeTraits<TResult>.ToBool(Invoke(context, parameters));
    }
  }
  /// <summary>
  /// Contextual custom function with 1 context variable and 2 parameters.
  /// </summary>
  internal sealed class ContextualCustomFunction<T1, T2, T3, TResult> : CustomFunction
  {
    private static readonly Type[] ParameterCache = new[]
    {
      TypeTraits<T2>.ValueType,
      TypeTraits<T3>.ValueType
    };
    private readonly Func<T1, T2, T3, TResult> _func;
    private readonly VariableId _contextVar1;

    public ContextualCustomFunction(string name, VariableId contextVar1, Func<T1, T2, T3, TResult> func, bool isDeterministic)
      : base(name, isDeterministic, ParameterCache, TypeTraits<TResult>.ValueType, hasContext: true)
    {
      _func = func ?? throw new ArgumentNullException(nameof(func));
      _contextVar1 = contextVar1;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private TResult Invoke(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureParameterCount(parameters);

      if (!context.TryGetVariable(_contextVar1, out T1 ctx1))
      {
        throw new RuntimeException($"Context variable '{_contextVar1}' not found");
      }

      return _func(ctx1, TypeTraits<T2>.Read(parameters[0]), TypeTraits<T3>.Read(parameters[1]));
    }

    internal override int ExecuteInt(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Integer);
      return TypeTraits<TResult>.ToInt(Invoke(context, parameters));
    }

    internal override long ExecuteLong(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Long);
      return TypeTraits<TResult>.ToLong(Invoke(context, parameters));
    }

    internal override float ExecuteFloat(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Float);
      return TypeTraits<TResult>.ToFloat(Invoke(context, parameters));
    }

    internal override double ExecuteDouble(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Double);
      return TypeTraits<TResult>.ToDouble(Invoke(context, parameters));
    }

    internal override decimal ExecuteDecimal(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Decimal);
      return TypeTraits<TResult>.ToDecimal(Invoke(context, parameters));
    }

    internal override string ExecuteString(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.String);
      return TypeTraits<TResult>.ToStringValue(Invoke(context, parameters));
    }

    internal override bool ExecuteBool(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Boolean);
      return TypeTraits<TResult>.ToBool(Invoke(context, parameters));
    }
  }
  /// <summary>
  /// Contextual custom function with 1 context variable and 3 parameters.
  /// </summary>
  internal sealed class ContextualCustomFunction<T1, T2, T3, T4, TResult> : CustomFunction
  {
    private static readonly Type[] ParameterCache = new[]
    {
      TypeTraits<T2>.ValueType,
      TypeTraits<T3>.ValueType,
      TypeTraits<T4>.ValueType
    };
    private readonly Func<T1, T2, T3, T4, TResult> _func;
    private readonly VariableId _contextVar1;

    public ContextualCustomFunction(string name, VariableId contextVar1, Func<T1, T2, T3, T4, TResult> func, bool isDeterministic)
      : base(name, isDeterministic, ParameterCache, TypeTraits<TResult>.ValueType, hasContext: true)
    {
      _func = func ?? throw new ArgumentNullException(nameof(func));
      _contextVar1 = contextVar1;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private TResult Invoke(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureParameterCount(parameters);

      if (!context.TryGetVariable(_contextVar1, out T1 ctx1))
      {
        throw new RuntimeException($"Context variable '{_contextVar1}' not found");
      }

      return _func(ctx1, TypeTraits<T2>.Read(parameters[0]), TypeTraits<T3>.Read(parameters[1]), TypeTraits<T4>.Read(parameters[2]));
    }

    internal override int ExecuteInt(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Integer);
      return TypeTraits<TResult>.ToInt(Invoke(context, parameters));
    }

    internal override long ExecuteLong(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Long);
      return TypeTraits<TResult>.ToLong(Invoke(context, parameters));
    }

    internal override float ExecuteFloat(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Float);
      return TypeTraits<TResult>.ToFloat(Invoke(context, parameters));
    }

    internal override double ExecuteDouble(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Double);
      return TypeTraits<TResult>.ToDouble(Invoke(context, parameters));
    }

    internal override decimal ExecuteDecimal(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Decimal);
      return TypeTraits<TResult>.ToDecimal(Invoke(context, parameters));
    }

    internal override string ExecuteString(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.String);
      return TypeTraits<TResult>.ToStringValue(Invoke(context, parameters));
    }

    internal override bool ExecuteBool(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Boolean);
      return TypeTraits<TResult>.ToBool(Invoke(context, parameters));
    }
  }
  // ===========================================================================
  // 2 Context Variables Implementations
  // ===========================================================================

  /// <summary>
  /// Contextual custom function with 2 context variables and 0 parameters.
  /// </summary>
  internal sealed class ContextualCustomFunction2<T1, T2, TResult> : CustomFunction
  {
    private readonly Func<T1, T2, TResult> _func;
    private readonly VariableId _contextVar1;
    private readonly VariableId _contextVar2;

    public ContextualCustomFunction2(string name, VariableId contextVar1, VariableId contextVar2, Func<T1, T2, TResult> func, bool isDeterministic)
      : base(name, isDeterministic, Array.Empty<Type>(), TypeTraits<TResult>.ValueType, hasContext: true)
    {
      _func = func ?? throw new ArgumentNullException(nameof(func));
      _contextVar1 = contextVar1;
      _contextVar2 = contextVar2;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private TResult Invoke(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureParameterCount(parameters);

      if (!context.TryGetVariable(_contextVar1, out T1 ctx1))
      {
        throw new RuntimeException($"Context variable '{_contextVar1}' not found");
      }

      if (!context.TryGetVariable(_contextVar2, out T2 ctx2))
      {
        throw new RuntimeException($"Context variable '{_contextVar2}' not found");
      }

      return _func(ctx1, ctx2);
    }

    internal override int ExecuteInt(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Integer);
      return TypeTraits<TResult>.ToInt(Invoke(context, parameters));
    }

    internal override long ExecuteLong(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Long);
      return TypeTraits<TResult>.ToLong(Invoke(context, parameters));
    }

    internal override float ExecuteFloat(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Float);
      return TypeTraits<TResult>.ToFloat(Invoke(context, parameters));
    }

    internal override double ExecuteDouble(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Double);
      return TypeTraits<TResult>.ToDouble(Invoke(context, parameters));
    }

    internal override decimal ExecuteDecimal(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Decimal);
      return TypeTraits<TResult>.ToDecimal(Invoke(context, parameters));
    }

    internal override string ExecuteString(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.String);
      return TypeTraits<TResult>.ToStringValue(Invoke(context, parameters));
    }

    internal override bool ExecuteBool(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Boolean);
      return TypeTraits<TResult>.ToBool(Invoke(context, parameters));
    }
  }
  /// <summary>
  /// Contextual custom function with 2 context variables and 1 parameter.
  /// </summary>
  internal sealed class ContextualCustomFunction2<T1, T2, T3, TResult> : CustomFunction
  {
    private static readonly Type[] ParameterCache = new[]
    {
      TypeTraits<T3>.ValueType
    };
    private readonly Func<T1, T2, T3, TResult> _func;
    private readonly VariableId _contextVar1;
    private readonly VariableId _contextVar2;

    public ContextualCustomFunction2(string name, VariableId contextVar1, VariableId contextVar2, Func<T1, T2, T3, TResult> func, bool isDeterministic)
      : base(name, isDeterministic, ParameterCache, TypeTraits<TResult>.ValueType, hasContext: true)
    {
      _func = func ?? throw new ArgumentNullException(nameof(func));
      _contextVar1 = contextVar1;
      _contextVar2 = contextVar2;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private TResult Invoke(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureParameterCount(parameters);

      if (!context.TryGetVariable(_contextVar1, out T1 ctx1))
      {
        throw new RuntimeException($"Context variable '{_contextVar1}' not found");
      }

      if (!context.TryGetVariable(_contextVar2, out T2 ctx2))
      {
        throw new RuntimeException($"Context variable '{_contextVar2}' not found");
      }

      return _func(ctx1, ctx2, TypeTraits<T3>.Read(parameters[0]));
    }

    internal override int ExecuteInt(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Integer);
      return TypeTraits<TResult>.ToInt(Invoke(context, parameters));
    }

    internal override long ExecuteLong(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Long);
      return TypeTraits<TResult>.ToLong(Invoke(context, parameters));
    }

    internal override float ExecuteFloat(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Float);
      return TypeTraits<TResult>.ToFloat(Invoke(context, parameters));
    }

    internal override double ExecuteDouble(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Double);
      return TypeTraits<TResult>.ToDouble(Invoke(context, parameters));
    }

    internal override decimal ExecuteDecimal(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Decimal);
      return TypeTraits<TResult>.ToDecimal(Invoke(context, parameters));
    }

    internal override string ExecuteString(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.String);
      return TypeTraits<TResult>.ToStringValue(Invoke(context, parameters));
    }

    internal override bool ExecuteBool(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Boolean);
      return TypeTraits<TResult>.ToBool(Invoke(context, parameters));
    }
  }
  /// <summary>
  /// Contextual custom function with 2 context variables and 2 parameters.
  /// </summary>
  internal sealed class ContextualCustomFunction2<T1, T2, T3, T4, TResult> : CustomFunction
  {
    private static readonly Type[] ParameterCache = new[]
    {
      TypeTraits<T3>.ValueType,
      TypeTraits<T4>.ValueType
    };
    private readonly Func<T1, T2, T3, T4, TResult> _func;
    private readonly VariableId _contextVar1;
    private readonly VariableId _contextVar2;

    public ContextualCustomFunction2(string name, VariableId contextVar1, VariableId contextVar2, Func<T1, T2, T3, T4, TResult> func, bool isDeterministic)
      : base(name, isDeterministic, ParameterCache, TypeTraits<TResult>.ValueType, hasContext: true)
    {
      _func = func ?? throw new ArgumentNullException(nameof(func));
      _contextVar1 = contextVar1;
      _contextVar2 = contextVar2;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private TResult Invoke(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureParameterCount(parameters);

      if (!context.TryGetVariable(_contextVar1, out T1 ctx1))
      {
        throw new RuntimeException($"Context variable '{_contextVar1}' not found");
      }

      if (!context.TryGetVariable(_contextVar2, out T2 ctx2))
      {
        throw new RuntimeException($"Context variable '{_contextVar2}' not found");
      }

      return _func(ctx1, ctx2, TypeTraits<T3>.Read(parameters[0]), TypeTraits<T4>.Read(parameters[1]));
    }

    internal override int ExecuteInt(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Integer);
      return TypeTraits<TResult>.ToInt(Invoke(context, parameters));
    }

    internal override long ExecuteLong(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Long);
      return TypeTraits<TResult>.ToLong(Invoke(context, parameters));
    }

    internal override float ExecuteFloat(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Float);
      return TypeTraits<TResult>.ToFloat(Invoke(context, parameters));
    }

    internal override double ExecuteDouble(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Double);
      return TypeTraits<TResult>.ToDouble(Invoke(context, parameters));
    }

    internal override decimal ExecuteDecimal(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Decimal);
      return TypeTraits<TResult>.ToDecimal(Invoke(context, parameters));
    }

    internal override string ExecuteString(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.String);
      return TypeTraits<TResult>.ToStringValue(Invoke(context, parameters));
    }

    internal override bool ExecuteBool(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Boolean);
      return TypeTraits<TResult>.ToBool(Invoke(context, parameters));
    }
  }
  /// <summary>
  /// Contextual custom function with 2 context variables and 3 parameters.
  /// </summary>
  internal sealed class ContextualCustomFunction2<T1, T2, T3, T4, T5, TResult> : CustomFunction
  {
    private static readonly Type[] ParameterCache = new[]
    {
      TypeTraits<T3>.ValueType,
      TypeTraits<T4>.ValueType,
      TypeTraits<T5>.ValueType
    };
    private readonly Func<T1, T2, T3, T4, T5, TResult> _func;
    private readonly VariableId _contextVar1;
    private readonly VariableId _contextVar2;

    public ContextualCustomFunction2(string name, VariableId contextVar1, VariableId contextVar2, Func<T1, T2, T3, T4, T5, TResult> func, bool isDeterministic)
      : base(name, isDeterministic, ParameterCache, TypeTraits<TResult>.ValueType, hasContext: true)
    {
      _func = func ?? throw new ArgumentNullException(nameof(func));
      _contextVar1 = contextVar1;
      _contextVar2 = contextVar2;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private TResult Invoke(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureParameterCount(parameters);

      if (!context.TryGetVariable(_contextVar1, out T1 ctx1))
      {
        throw new RuntimeException($"Context variable '{_contextVar1}' not found");
      }

      if (!context.TryGetVariable(_contextVar2, out T2 ctx2))
      {
        throw new RuntimeException($"Context variable '{_contextVar2}' not found");
      }

      return _func(ctx1, ctx2, TypeTraits<T3>.Read(parameters[0]), TypeTraits<T4>.Read(parameters[1]), TypeTraits<T5>.Read(parameters[2]));
    }

    internal override int ExecuteInt(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Integer);
      return TypeTraits<TResult>.ToInt(Invoke(context, parameters));
    }

    internal override long ExecuteLong(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Long);
      return TypeTraits<TResult>.ToLong(Invoke(context, parameters));
    }

    internal override float ExecuteFloat(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Float);
      return TypeTraits<TResult>.ToFloat(Invoke(context, parameters));
    }

    internal override double ExecuteDouble(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Double);
      return TypeTraits<TResult>.ToDouble(Invoke(context, parameters));
    }

    internal override decimal ExecuteDecimal(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Decimal);
      return TypeTraits<TResult>.ToDecimal(Invoke(context, parameters));
    }

    internal override string ExecuteString(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.String);
      return TypeTraits<TResult>.ToStringValue(Invoke(context, parameters));
    }

    internal override bool ExecuteBool(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Boolean);
      return TypeTraits<TResult>.ToBool(Invoke(context, parameters));
    }
  }
  // ===========================================================================
  // 3 Context Variables Implementations
  // ===========================================================================

  /// <summary>
  /// Contextual custom function with 3 context variables and 0 parameters.
  /// </summary>
  internal sealed class ContextualCustomFunction3<T1, T2, T3, TResult> : CustomFunction
  {
    private readonly Func<T1, T2, T3, TResult> _func;
    private readonly VariableId _contextVar1;
    private readonly VariableId _contextVar2;
    private readonly VariableId _contextVar3;

    public ContextualCustomFunction3(string name, VariableId contextVar1, VariableId contextVar2, VariableId contextVar3, Func<T1, T2, T3, TResult> func, bool isDeterministic)
      : base(name, isDeterministic, Array.Empty<Type>(), TypeTraits<TResult>.ValueType, hasContext: true)
    {
      _func = func ?? throw new ArgumentNullException(nameof(func));
      _contextVar1 = contextVar1;
      _contextVar2 = contextVar2;
      _contextVar3 = contextVar3;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private TResult Invoke(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureParameterCount(parameters);

      if (!context.TryGetVariable(_contextVar1, out T1 ctx1))
      {
        throw new RuntimeException($"Context variable '{_contextVar1}' not found");
      }

      if (!context.TryGetVariable(_contextVar2, out T2 ctx2))
      {
        throw new RuntimeException($"Context variable '{_contextVar2}' not found");
      }

      if (!context.TryGetVariable(_contextVar3, out T3 ctx3))
      {
        throw new RuntimeException($"Context variable '{_contextVar3}' not found");
      }

      return _func(ctx1, ctx2, ctx3);
    }

    internal override int ExecuteInt(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Integer);
      return TypeTraits<TResult>.ToInt(Invoke(context, parameters));
    }

    internal override long ExecuteLong(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Long);
      return TypeTraits<TResult>.ToLong(Invoke(context, parameters));
    }

    internal override float ExecuteFloat(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Float);
      return TypeTraits<TResult>.ToFloat(Invoke(context, parameters));
    }

    internal override double ExecuteDouble(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Double);
      return TypeTraits<TResult>.ToDouble(Invoke(context, parameters));
    }

    internal override decimal ExecuteDecimal(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Decimal);
      return TypeTraits<TResult>.ToDecimal(Invoke(context, parameters));
    }

    internal override string ExecuteString(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.String);
      return TypeTraits<TResult>.ToStringValue(Invoke(context, parameters));
    }

    internal override bool ExecuteBool(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Boolean);
      return TypeTraits<TResult>.ToBool(Invoke(context, parameters));
    }
  }
  /// <summary>
  /// Contextual custom function with 3 context variables and 1 parameter.
  /// </summary>
  internal sealed class ContextualCustomFunction3<T1, T2, T3, T4, TResult> : CustomFunction
  {
    private static readonly Type[] ParameterCache = new[]
    {
      TypeTraits<T4>.ValueType
    };
    private readonly Func<T1, T2, T3, T4, TResult> _func;
    private readonly VariableId _contextVar1;
    private readonly VariableId _contextVar2;
    private readonly VariableId _contextVar3;

    public ContextualCustomFunction3(string name, VariableId contextVar1, VariableId contextVar2, VariableId contextVar3, Func<T1, T2, T3, T4, TResult> func, bool isDeterministic)
      : base(name, isDeterministic, ParameterCache, TypeTraits<TResult>.ValueType, hasContext: true)
    {
      _func = func ?? throw new ArgumentNullException(nameof(func));
      _contextVar1 = contextVar1;
      _contextVar2 = contextVar2;
      _contextVar3 = contextVar3;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private TResult Invoke(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureParameterCount(parameters);

      if (!context.TryGetVariable(_contextVar1, out T1 ctx1))
      {
        throw new RuntimeException($"Context variable '{_contextVar1}' not found");
      }

      if (!context.TryGetVariable(_contextVar2, out T2 ctx2))
      {
        throw new RuntimeException($"Context variable '{_contextVar2}' not found");
      }

      if (!context.TryGetVariable(_contextVar3, out T3 ctx3))
      {
        throw new RuntimeException($"Context variable '{_contextVar3}' not found");
      }

      return _func(ctx1, ctx2, ctx3, TypeTraits<T4>.Read(parameters[0]));
    }

    internal override int ExecuteInt(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Integer);
      return TypeTraits<TResult>.ToInt(Invoke(context, parameters));
    }

    internal override long ExecuteLong(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Long);
      return TypeTraits<TResult>.ToLong(Invoke(context, parameters));
    }

    internal override float ExecuteFloat(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Float);
      return TypeTraits<TResult>.ToFloat(Invoke(context, parameters));
    }

    internal override double ExecuteDouble(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Double);
      return TypeTraits<TResult>.ToDouble(Invoke(context, parameters));
    }

    internal override decimal ExecuteDecimal(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Decimal);
      return TypeTraits<TResult>.ToDecimal(Invoke(context, parameters));
    }

    internal override string ExecuteString(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.String);
      return TypeTraits<TResult>.ToStringValue(Invoke(context, parameters));
    }

    internal override bool ExecuteBool(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Boolean);
      return TypeTraits<TResult>.ToBool(Invoke(context, parameters));
    }
  }
  /// <summary>
  /// Contextual custom function with 3 context variables and 2 parameters.
  /// </summary>
  internal sealed class ContextualCustomFunction3<T1, T2, T3, T4, T5, TResult> : CustomFunction
  {
    private static readonly Type[] ParameterCache = new[]
    {
      TypeTraits<T4>.ValueType,
      TypeTraits<T5>.ValueType
    };
    private readonly Func<T1, T2, T3, T4, T5, TResult> _func;
    private readonly VariableId _contextVar1;
    private readonly VariableId _contextVar2;
    private readonly VariableId _contextVar3;

    public ContextualCustomFunction3(string name, VariableId contextVar1, VariableId contextVar2, VariableId contextVar3, Func<T1, T2, T3, T4, T5, TResult> func, bool isDeterministic)
      : base(name, isDeterministic, ParameterCache, TypeTraits<TResult>.ValueType, hasContext: true)
    {
      _func = func ?? throw new ArgumentNullException(nameof(func));
      _contextVar1 = contextVar1;
      _contextVar2 = contextVar2;
      _contextVar3 = contextVar3;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private TResult Invoke(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureParameterCount(parameters);

      if (!context.TryGetVariable(_contextVar1, out T1 ctx1))
      {
        throw new RuntimeException($"Context variable '{_contextVar1}' not found");
      }

      if (!context.TryGetVariable(_contextVar2, out T2 ctx2))
      {
        throw new RuntimeException($"Context variable '{_contextVar2}' not found");
      }

      if (!context.TryGetVariable(_contextVar3, out T3 ctx3))
      {
        throw new RuntimeException($"Context variable '{_contextVar3}' not found");
      }

      return _func(ctx1, ctx2, ctx3, TypeTraits<T4>.Read(parameters[0]), TypeTraits<T5>.Read(parameters[1]));
    }

    internal override int ExecuteInt(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Integer);
      return TypeTraits<TResult>.ToInt(Invoke(context, parameters));
    }

    internal override long ExecuteLong(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Long);
      return TypeTraits<TResult>.ToLong(Invoke(context, parameters));
    }

    internal override float ExecuteFloat(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Float);
      return TypeTraits<TResult>.ToFloat(Invoke(context, parameters));
    }

    internal override double ExecuteDouble(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Double);
      return TypeTraits<TResult>.ToDouble(Invoke(context, parameters));
    }

    internal override decimal ExecuteDecimal(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Decimal);
      return TypeTraits<TResult>.ToDecimal(Invoke(context, parameters));
    }

    internal override string ExecuteString(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.String);
      return TypeTraits<TResult>.ToStringValue(Invoke(context, parameters));
    }

    internal override bool ExecuteBool(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Boolean);
      return TypeTraits<TResult>.ToBool(Invoke(context, parameters));
    }
  }
  /// <summary>
  /// Contextual custom function with 3 context variables and 3 parameters.
  /// </summary>
  internal sealed class ContextualCustomFunction3<T1, T2, T3, T4, T5, T6, TResult> : CustomFunction
  {
    private static readonly Type[] ParameterCache = new[]
    {
      TypeTraits<T4>.ValueType,
      TypeTraits<T5>.ValueType,
      TypeTraits<T6>.ValueType
    };
    private readonly Func<T1, T2, T3, T4, T5, T6, TResult> _func;
    private readonly VariableId _contextVar1;
    private readonly VariableId _contextVar2;
    private readonly VariableId _contextVar3;

    public ContextualCustomFunction3(string name, VariableId contextVar1, VariableId contextVar2, VariableId contextVar3, Func<T1, T2, T3, T4, T5, T6, TResult> func, bool isDeterministic)
      : base(name, isDeterministic, ParameterCache, TypeTraits<TResult>.ValueType, hasContext: true)
    {
      _func = func ?? throw new ArgumentNullException(nameof(func));
      _contextVar1 = contextVar1;
      _contextVar2 = contextVar2;
      _contextVar3 = contextVar3;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private TResult Invoke(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureParameterCount(parameters);

      if (!context.TryGetVariable(_contextVar1, out T1 ctx1))
      {
        throw new RuntimeException($"Context variable '{_contextVar1}' not found");
      }

      if (!context.TryGetVariable(_contextVar2, out T2 ctx2))
      {
        throw new RuntimeException($"Context variable '{_contextVar2}' not found");
      }

      if (!context.TryGetVariable(_contextVar3, out T3 ctx3))
      {
        throw new RuntimeException($"Context variable '{_contextVar3}' not found");
      }

      return _func(ctx1, ctx2, ctx3, TypeTraits<T4>.Read(parameters[0]), TypeTraits<T5>.Read(parameters[1]), TypeTraits<T6>.Read(parameters[2]));
    }

    internal override int ExecuteInt(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Integer);
      return TypeTraits<TResult>.ToInt(Invoke(context, parameters));
    }

    internal override long ExecuteLong(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Long);
      return TypeTraits<TResult>.ToLong(Invoke(context, parameters));
    }

    internal override float ExecuteFloat(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Float);
      return TypeTraits<TResult>.ToFloat(Invoke(context, parameters));
    }

    internal override double ExecuteDouble(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Double);
      return TypeTraits<TResult>.ToDouble(Invoke(context, parameters));
    }

    internal override decimal ExecuteDecimal(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Decimal);
      return TypeTraits<TResult>.ToDecimal(Invoke(context, parameters));
    }

    internal override string ExecuteString(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.String);
      return TypeTraits<TResult>.ToStringValue(Invoke(context, parameters));
    }

    internal override bool ExecuteBool(VariableContextAdapter context, List<Node> parameters)
    {
      EnsureReturnType(Type.Boolean);
      return TypeTraits<TResult>.ToBool(Invoke(context, parameters));
    }
  }
}
